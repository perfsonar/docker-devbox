#
# Common Functions
#

WHOAMI=$(basename $0)
WHEREAMI=$(dirname $0)

warn()
{
    [ "$@" ] && echo "$@" 1>&2
}

die()
{
    warn "$@"
    exit 1
}

[ -d "${DDB}" ] || die "Can't find DDB directory."


# A low-budget, shell-based readlink because MacOS doesn't have it.
shreadlink()
{
    FILE=$1

    while true
    do
        if [ ! -L "${FILE}" ]
        then
            break
        fi
        LS_LINK=$(ls -dl "${FILE}" | sed -e 's/^.*-> //')
        if echo ${LS_LINK} | egrep -q -e '^/'
        then
            # Absolute path
            FILE="${LS_LINK}"
        else
            # Path relative to this directory
            DIR=$(dirname "${FILE}")
            FILE="${DIR}/${LS_LINK}"
        fi
    done

    # Ajust for the first part of the path being absolute or relative
    case "${FILE}" in
	.|..)
	    FILE=$(cd "${FILE}" && pwd)
	    ;;
	./*|../*)
	    REL_PART=$(echo "${FILE}" | cut -d / -f 1)
	    # REST_PART will have a slash built in.
	    REL_PWD=$(cd "${REL_PART}" && pwd | sed -e 's|^/$||')
	    REST_PART=$(echo "${FILE}" | cut -d / -f 2-)
	    FILE="${REL_PWD}/${REST_PART}"
	    ;;
    esac

    echo "${FILE}"
}


# Canonicalize DDB
DDB=$(shreadlink "${DDB}")


DDB_ETC="${DDB}/../etc"

# Since these get run as root, the names need to be unique by user.
DDB_CONTAINER_PREFIX="ddb__$(id -un)__"

# Directory in the container where DDB's files live
DDB_DIR="/.ddb"

export DDB_COMMANDS="${DDB}/commands"


TMPBASE=$(mktemp -d)

# Root and macOS don't need sudo
if [ "$(uname -s)" = "Darwin" -o "$(id -u)" = 0 ]
then
    DOCKER="docker"
else
    DOCKER="sudo docker"
fi

    
# Strip comments and blanks out of key/value file $1 and find the
# value for key #2.
getkey()
{
    VALUE=$(sed -e 's/^\s*#.*$//g; /^$/d' "$1" \
		| awk -v "KEY=$2" '$1 == KEY { print $2; exit 0 }')
    
    if [ -z "${VALUE}" ]
    then
	echo "$2: Not found in $1" 1>&2
	exit 1
    fi

    echo "${VALUE}"
}








#
# CLEANUP ON EXIT
#

ddb_cleanup()
{
    rm -rf "${TMPBASE}"
}
trap ddb_cleanup EXIT
